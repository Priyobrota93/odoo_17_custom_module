)]}'
{"version": 3, "sources": ["/web/static/src/webclient/clickbot/clickbot.js"], "mappings": "AAAA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/** @odoo-module **/\n\n/**\n * The purpose of this test is to click on every installed App and then open each\n * view. On each view, click on each filter.\n */\n\nimport { App } from \"@odoo/owl\";\nimport { browser } from \"@web/core/browser/browser\";\n\nconst MOUSE_EVENTS = [\"mouseover\", \"mouseenter\", \"mousedown\", \"mouseup\", \"click\"];\nconst BLACKLISTED_MENUS = [\n    \"base.menu_theme_store\", // Open a new tab\n    \"base.menu_third_party\", // Open a new tab\n    \"event.menu_event_registration_desk\", // there's no way to come back from this menu (tablet mode)\n    \"hr_attendance.menu_hr_attendance_kiosk_no_user_mode\", // same here (tablet mode)\n    \"mrp_workorder.menu_mrp_workorder_root\", // same here (tablet mode)\n    \"account.menu_action_account_bank_journal_form\", // Modal in an iFrame\n    \"pos_preparation_display.menu_point_kitchen_display_root\", // conditional menu that may leads to frontend\n];\n// If you change this selector, adapt Studio test \"Studio icon matches the clickbot selector\"\nconst STUDIO_SYSTRAY_ICON_SELECTOR = \".o_web_studio_navbar_item:not(.o_disabled) i\";\n\nlet isEnterprise;\nlet appsMenusOnly = false;\nlet calledRPC;\nlet errorRPC;\nlet actionCount;\nlet env;\nlet studioCount;\n\nlet appIndex;\nlet menuIndex;\nlet subMenuIndex;\nlet testedApps;\nlet testedMenus;\nlet testedFilters;\nlet testedModals;\n\n/**\n * Hook on specific activities of the webclient to detect when to move forward.\n * This should be done only once.\n */\nfunction setup() {\n    env = odoo.__WOWL_DEBUG__.root.env;\n    env.bus.addEventListener(\"ACTION_MANAGER:UI-UPDATED\", uiUpdate);\n    env.bus.addEventListener(\"RPC:REQUEST\", onRPCRequest);\n    env.bus.addEventListener(\"RPC:RESPONSE\", onRPCResponse);\n    actionCount = 0;\n    calledRPC = {};\n    errorRPC = undefined;\n    studioCount = 0;\n    testedApps = [];\n    testedMenus = [];\n    testedFilters = 0;\n    testedModals = 0;\n    appIndex = 0;\n    menuIndex = 0;\n    subMenuIndex = 0;\n    isEnterprise = odoo.info && odoo.info.isEnterprise;\n}\n\nfunction onRPCRequest({ detail }) {\n    calledRPC[detail.data.id] = detail.url;\n}\n\nfunction onRPCResponse({ detail }) {\n    delete calledRPC[detail.data.id];\n    if (detail.error) {\n        errorRPC = { ...detail };\n    }\n}\n\nfunction uiUpdate() {\n    actionCount++;\n}\n\nfunction cleanup() {\n    env.bus.removeEventListener(\"ACTION_MANAGER:UI-UPDATED\", uiUpdate);\n    env.bus.removeEventListener(\"RPC:REQUEST\", onRPCRequest);\n    env.bus.removeEventListener(\"RPC:RESPONSE\", onRPCResponse);\n}\n\n/**\n * Returns a promise that resolves after the next animation frame.\n *\n * @returns {Promise}\n */\nasync function waitForNextAnimationFrame() {\n    await new Promise(browser.setTimeout);\n    await new Promise((r) => requestAnimationFrame(r));\n}\n\n/**\n * Simulate all of the mouse events triggered during a click action.\n *\n * @param {EventTarget} target the element on which to perform the click\n * @param {string} elDescription description of the item\n * @returns {Promise} resolved after next animation frame\n */\nasync function triggerClick(target, elDescription) {\n    if (target) {\n        if (elDescription) {\n            browser.console.log(`Clicking on: ${elDescription}`);\n        }\n    } else {\n        throw new Error(`No element \"${elDescription}\" found.`);\n    }\n    MOUSE_EVENTS.forEach((type) => {\n        const event = new MouseEvent(type, { bubbles: true, cancelable: true, view: window });\n        target.dispatchEvent(event);\n    });\n    await waitForNextAnimationFrame();\n}\n\n/**\n * Wait a certain amount of time for a condition to occur\n *\n * @param {function} stopCondition a function that returns a boolean\n * @returns {Promise} that is rejected if the timeout is exceeded\n */\nasync function waitForCondition(stopCondition) {\n    const interval = 25;\n    const initialTime = 30000;\n    let timeLimit = initialTime;\n\n    function hasPendingRPC() {\n        return Object.keys(calledRPC).length > 0;\n    }\n    function hasScheduledTask() {\n        let size = 0;\n        for (const app of App.apps) {\n            size += app.scheduler.tasks.size;\n        }\n        return size > 0;\n    }\n    function errorDialog() {\n        if (document.querySelector(\".o_error_dialog\")) {\n            if (errorRPC) {\n                browser.console.error(\n                    \"A RPC in error was detected, maybe it's related to the error dialog : \" +\n                        JSON.stringify(errorRPC)\n                );\n            }\n            throw new Error(\n                \"Error dialog detected\" + document.querySelector(\".o_error_dialog\").innerHTML\n            );\n        }\n        return false;\n    }\n\n    while (errorDialog() || !stopCondition() || hasPendingRPC() || hasScheduledTask()) {\n        if (timeLimit <= 0) {\n            let msg = `Timeout, the clicked element took more than ${\n                initialTime / 1000\n            } seconds to load\\n`;\n            msg += `Waiting for:\\n`;\n            if (Object.keys(calledRPC).length > 0) {\n                msg += ` * ${Object.values(calledRPC).join(\", \")} RPC\\n`;\n            }\n            let scheduleTasks = \"\";\n            for (const app of App.apps) {\n                for (const task of app.scheduler.tasks) {\n                    scheduleTasks += task.node.name + \",\";\n                }\n            }\n            if (scheduleTasks.length > 0) {\n                msg += ` * ${scheduleTasks} scheduled tasks\\n`;\n            }\n            if (!stopCondition()) {\n                msg += ` * stopCondition: ${stopCondition.toString()}`;\n            }\n            throw new Error(msg);\n        }\n        await new Promise((resolve) => setTimeout(resolve, interval));\n        timeLimit -= interval;\n    }\n}\n\n/**\n * Make sure the home menu is open (enterprise only)\n */\nasync function ensureHomeMenu() {\n    const homeMenu = document.querySelector(\"div.o_home_menu\");\n    if (!homeMenu) {\n        let menuToggle = document.querySelector(\"nav.o_main_navbar > a.o_menu_toggle\");\n        if (!menuToggle) {\n            // In the Barcode application, there is no navbar. So you have to click\n            // on the o_stock_barcode_menu button which is the equivalent of\n            // the o_menu_toggle button in the navbar.\n            menuToggle = document.querySelector(\".o_stock_barcode_menu\");\n        }\n        await triggerClick(menuToggle, \"home menu toggle button\");\n        await waitForCondition(() => document.querySelector(\"div.o_home_menu\"));\n    }\n}\n\n/**\n * Make sure the apps menu is open (community only)\n */\nasync function ensureAppsMenu() {\n    const appsMenu = document.querySelector(\".o_navbar_apps_menu .dropdown-menu\");\n    if (!appsMenu) {\n        const toggler = document.querySelector(\".o_navbar_apps_menu .dropdown-toggle\");\n        await triggerClick(toggler, \"apps menu toggle button\");\n        await waitForCondition(() => document.querySelector(\".o_navbar_apps_menu .dropdown-menu\"));\n    }\n}\n\n/**\n * Return the next menu to test, and update the internal counters.\n *\n * @returns {DomElement}\n */\nasync function getNextMenu() {\n    const menus = document.querySelectorAll(\n        \".o_menu_sections > .dropdown > .dropdown-toggle, .o_menu_sections > .dropdown-item\"\n    );\n    if (menuIndex === menus.length) {\n        menuIndex = 0;\n        return; // all menus done\n    }\n    let menu = menus[menuIndex];\n    if (menu.classList.contains(\"dropdown-toggle\")) {\n        // the current menu is a dropdown toggler -> open it and pick a menu inside the dropdown\n        if (!menu.nextElementSibling) {\n            // might already be opened if the last menu was blacklisted\n            await triggerClick(menu, \"menu toggler\");\n        }\n        const dropdown = menu.nextElementSibling;\n        if (!dropdown) {\n            menuIndex = 0; // empty More menu has no dropdown (FIXME?)\n            return;\n        }\n        const items = dropdown.querySelectorAll(\".dropdown-item\");\n        menu = items[subMenuIndex];\n        if (subMenuIndex === items.length - 1) {\n            // this is the last item, so go to the next menu\n            menuIndex++;\n            subMenuIndex = 0;\n        } else {\n            // this isn't the last item, so increment the index inside this dropdown\n            subMenuIndex++;\n        }\n    } else {\n        // the current menu isn't a dropdown, so go to the next menu\n        menuIndex++;\n    }\n    return menu;\n}\n\n/**\n * Return the next app to test, and update the internal counter.\n *\n * @returns {DomElement}\n */\nasync function getNextApp() {\n    let apps;\n    if (isEnterprise) {\n        await ensureHomeMenu();\n        apps = document.querySelectorAll(\".o_apps .o_app\");\n    } else {\n        await ensureAppsMenu();\n        apps = document.querySelectorAll(\".o_navbar_apps_menu .dropdown-item\");\n    }\n    const app = apps[appIndex];\n    appIndex++;\n    return app;\n}\n\n/**\n * Test Studio\n * Click on the Studio systray item to enter Studio, and simply leave it once loaded.\n */\nasync function testStudio() {\n    const studioIcon = document.querySelector(STUDIO_SYSTRAY_ICON_SELECTOR);\n    if (!studioIcon) {\n        return;\n    }\n    // Open the filter menu dropdown\n    await triggerClick(studioIcon, \"entering studio\");\n    await waitForCondition(() => document.querySelector(\".o_in_studio\"));\n    await triggerClick(document.querySelector(\".o_web_studio_leave\"), \"leaving studio\");\n    await waitForCondition(() =>\n        document.querySelector(\".o_main_navbar:not(.o_studio_navbar) .o_menu_toggle\")\n    );\n    studioCount++;\n}\n\n/**\n * Test filters\n * Click on each filter in the control pannel\n */\nasync function testFilters() {\n    if (appsMenusOnly === true) {\n        return;\n    }\n    const searchBarMenu = document.querySelector(\n        \".o_control_panel .dropdown-toggle.o_searchview_dropdown_toggler\"\n    );\n    if (!searchBarMenu) {\n        return;\n    }\n    // Open the search bar menu dropdown\n    await triggerClick(searchBarMenu);\n    const filterMenuButton = document.querySelector(\n        \".o_control_panel .o_dropdown_container.o_filter_menu\"\n    );\n    // Is there a filter menu in the search bar\n    if (!filterMenuButton) {\n        return;\n    }\n\n    // Avoid the \"Custom Filter\" menu item (it don't have the class .o_menu_item)\n    const simpleFilterSel =\n        \".o_control_panel .o_filter_menu > .dropdown-item.o_menu_item:not(.o_add_custom_filter)\";\n    const dateFilterSel = \".o_control_panel .o_filter_menu > .o_accordion\";\n    const filterMenuItems = document.querySelectorAll(`${simpleFilterSel},${dateFilterSel}`);\n    browser.console.log(`Testing ${filterMenuItems.length} filters`);\n    testedFilters += filterMenuItems.length;\n    for (const filter of filterMenuItems) {\n        // Date filters\n        if (filter.classList.contains(\"o_accordion\")) {\n            // If a fitler has options, it will simply unfold and show all options.\n            await triggerClick(\n                filter.querySelector(\".o_accordion_toggle\"),\n                `filter \"${filter.innerText.trim()}\"`\n            );\n\n            // If a fitler has options, it will simply unfold and show all options.\n            // We then click on the first one.\n            const firstOption = filter.querySelector(\n                \".o_accordion > .o_accordion_values > .dropdown-item\"\n            );\n            if (firstOption) {\n                await triggerClick(firstOption, `filter option \"${firstOption.innerText.trim()}\"`);\n                await waitForCondition(() => true);\n            }\n        } else {\n            await triggerClick(filter, `filter \"${filter.innerText.trim()}\"`);\n            await waitForCondition(() => true);\n        }\n    }\n}\n\n/**\n * Orchestrate the test of views\n * This function finds the buttons that permit to switch views and orchestrate\n * the click on each of them\n * @returns {Promise}\n */\nasync function testViews() {\n    if (appsMenusOnly === true) {\n        return;\n    }\n    const switchButtons = document.querySelectorAll(\n        \"nav.o_cp_switch_buttons > button.o_switch_view:not(.active):not(.o_map)\"\n    );\n    for (const switchButton of switchButtons) {\n        // Only way to get the viewType from the switchButton\n        const viewType = [...switchButton.classList]\n            .find((cls) => cls !== \"o_switch_view\" && cls.startsWith(\"o_\"))\n            .slice(2);\n        browser.console.log(`Testing view switch: ${viewType}`);\n        // timeout to avoid click debounce\n        browser.setTimeout(function () {\n            const target = document.querySelector(\n                `nav.o_cp_switch_buttons > button.o_switch_view.o_${viewType}`\n            );\n            if (target) {\n                triggerClick(target, `${viewType} view switcher`);\n            }\n        }, 250);\n        await waitForCondition(() => {\n            return document.querySelector(`.o_switch_view.o_${viewType}.active`) !== null;\n        });\n        await testStudio();\n        await testFilters();\n    }\n}\n\n/**\n * Test a menu item by:\n *  1 - clikcing on the menuItem\n *  2 - Orchestrate the view switch\n *\n *  @param {DomElement} element: the menu item\n *  @returns {Promise}\n */\nasync function testMenuItem(element) {\n    const menu = element.dataset.menuXmlid;\n    const menuDescription = element.innerText.trim() + \" \" + menu;\n    if (BLACKLISTED_MENUS.includes(menu)) {\n        browser.console.log(`Skipping blacklisted menu ${menuDescription}`);\n        return Promise.resolve(); // Skip black listed menus\n    }\n    browser.console.log(`Testing menu ${menuDescription}`);\n    testedMenus.push(menu);\n    const startActionCount = actionCount;\n    await triggerClick(element, `menu item \"${element.innerText.trim()}\"`);\n    try {\n        let isModal = false;\n        await waitForCondition(() => {\n            if (document.querySelector(\".o_dialog:not(.o_error_dialog)\")) {\n                isModal = true;\n                browser.console.log(`Modal detected: ${menuDescription}`);\n                testedModals++;\n                return true;\n            } else {\n                return startActionCount !== actionCount;\n            }\n        });\n        if (isModal) {\n            await triggerClick(\n                document.querySelector(\".o_dialog header > .btn-close\"),\n                \"modal close button\"\n            );\n        } else {\n            await testStudio();\n            await testFilters();\n            await testViews();\n        }\n    } catch (err) {\n        browser.console.error(`Error while testing ${menuDescription}`);\n        throw err;\n    }\n}\n\n/**\n * Test an \"App\" menu item by orchestrating the following actions:\n *  1 - clicking on its menuItem\n *  2 - clicking on each view\n *  3 - clicking on each menu\n *  3.1  - clicking on each view\n * @param {DomElement} element: the App menu item\n * @returns {Promise}\n */\nasync function testApp(element) {\n    browser.console.log(`Testing app menu: ${element.dataset.menuXmlid}`);\n    testedApps.push(element.dataset.menuXmlid);\n    await testMenuItem(element);\n    if (appsMenusOnly === true) {\n        return;\n    }\n    menuIndex = 0;\n    subMenuIndex = 0;\n    let menu = await getNextMenu();\n    while (menu) {\n        await testMenuItem(menu);\n        menu = await getNextMenu();\n    }\n}\n\n/**\n * Main function that starts orchestration of tests\n */\nasync function _clickEverywhere(xmlId) {\n    setup();\n    console.log(\"Starting ClickEverywhere test\");\n    console.log(`Odoo flavor: ${isEnterprise ? \"Enterprise\" : \"Community\"}`);\n    const startTime = performance.now();\n    try {\n        let app;\n        if (xmlId) {\n            if (isEnterprise) {\n                app = document.querySelector(`a.o_app.o_menuitem[data-menu-xmlid=\"${xmlId}\"]`);\n            } else {\n                await triggerClick(document.querySelector(\".o_navbar_apps_menu .dropdown-toggle\"));\n                app = document.querySelector(\n                    `.o_navbar_apps_menu .dropdown-item[data-menu-xmlid=\"${xmlId}\"]`\n                );\n            }\n            if (!app) {\n                throw new Error(`No app found for xmlid ${xmlId}`);\n            }\n            await testApp(app);\n        } else {\n            while ((app = await getNextApp())) {\n                await testApp(app);\n            }\n        }\n\n        console.log(`Test took ${(performance.now() - startTime) / 1000} seconds`);\n        browser.console.log(`Successfully tested ${testedApps.length} apps`);\n        browser.console.log(`Successfully tested ${testedMenus.length - testedApps.length} menus`);\n        browser.console.log(`Successfully tested ${testedModals} modals`);\n        browser.console.log(`Successfully tested ${testedFilters} filters`);\n        if (studioCount > 0) {\n            browser.console.log(`Successfully tested ${studioCount} views in Studio`);\n        }\n        browser.console.log(\"test successful\");\n    } catch (err) {\n        console.log(`Test took ${(performance.now() - startTime) / 1000} seconds`);\n        browser.console.error(err || \"test failed\");\n    } finally {\n        cleanup();\n    }\n}\n\nfunction clickEverywhere(xmlId, light) {\n    appsMenusOnly = light;\n    browser.setTimeout(_clickEverywhere, 1000, xmlId);\n}\n\nwindow.clickEverywhere = clickEverywhere;\n"], "file": "/web/assets/802391a/web.assets_clickbot.js", "sourceRoot": "../../../"}